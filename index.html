<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Realm of Factions ‚Äî –¶–∞—Ä—Å—Ç–≤–æ –§—Ä–∞–∫—Ü–∏–π</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { 
  background:#000; font-family:'Segoe UI',sans-serif; overflow:hidden;
  touch-action: none; /* Prevent pull-to-refresh and other gestures */
  -webkit-user-select: none;
  user-select: none;
}
#canvas { display:block; touch-action: none; }
#ui {
  position:fixed; top:0; left:0; width:100%; height:100%;
  pointer-events:none; z-index:10;
}
#hud {
  position:fixed; bottom:0; left:50%; transform:translateX(-50%);
  display:flex; justify-content:center; align-items:center;
  padding:12px 20px; pointer-events:none; gap:15px;
  flex-wrap:wrap; max-width:95vw;
}

/* Landscape mode: move HUD to top */
@media (orientation: landscape) and (max-width: 915px) {
  #hud {
    top: 4px; 
    bottom: auto; 
    left: 50%;
    transform: translateX(-50%);
    padding: 4px 12px;
    gap: 10px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 12px;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
  }
  .bar-wrap {
    flex-direction: row;
    align-items: center;
    gap: 4px;
    min-width: auto;
  }
  .bar {
    height: 6px;
    width: 70px;
    border: none;
    background: rgba(0, 0, 0, 0.4);
  }
  .bar-label {
    font-size: 10px;
    white-space: nowrap;
    opacity: 0.9;
  }
  #gold-hud {
    font-size: 11px;
    opacity: 0.95;
  }
  #shop-btn-hud {
    display: inline-block;
    padding: 4px 10px;
    font-size: 9px;
    margin-left: 6px;
    background: rgba(241, 196, 15, 0.75);
    border-radius: 6px;
    opacity: 0.9;
  }
  #shop-btn-hud:active {
    opacity: 1;
  }
}
.bar-wrap { display:flex; flex-direction:column; gap:4px; min-width:140px; flex:1; max-width:180px; }
.bar-label { color:#fff; font-size:11px; text-shadow:1px 1px 3px #000; text-align:center; }
.bar { height:14px; border-radius:7px; border:1px solid rgba(255,255,255,0.3);
  background:rgba(0,0,0,0.5); overflow:hidden; }
.bar-inner { height:100%; border-radius:7px; transition:width 0.3s; }
#hp-bar .bar-inner   { background:linear-gradient(90deg,#c0392b,#e74c3c); }
#sta-bar .bar-inner  { background:linear-gradient(90deg,#27ae60,#2ecc71); }
#gold-hud { color:#f1c40f; font-size:14px; font-weight:700;
  text-shadow:0 0 8px #f39c12; white-space:nowrap; }

/* Shop button in HUD */
#shop-btn-hud {
  display: none; /* Hidden by default, shown in mobile mode */
  padding: 8px 16px; background: rgba(241, 196, 15, 0.9);
  color: #000; border: none; border-radius: 8px;
  font-size: 13px; font-weight: 700; cursor: pointer;
  pointer-events: all;
  transition: all 0.2s;
  margin-left: 12px;
}
#shop-btn-hud:active { background: rgba(241, 196, 15, 1); transform: scale(0.95); }

#crosshair {
  position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
  width:24px; height:24px; pointer-events:none; opacity:0.8;
}
#crosshair::before, #crosshair::after {
  content:''; position:absolute; background:#fff;
  box-shadow:0 0 4px rgba(0,0,0,0.8);
}
#crosshair::before { width:2px; height:24px; left:11px; top:0; }
#crosshair::after  { width:24px; height:2px; top:11px; left:0; }

#minimap {
  position:fixed; top:12px; right:12px; width:140px; height:140px;
  border:2px solid rgba(255,255,255,0.4); border-radius:8px;
  background:rgba(0,0,0,0.6); overflow:hidden;
}
#minimap canvas { display:block; }

/* Landscape mode: smaller minimap */
@media (orientation: landscape) and (max-width: 915px) {
  #minimap {
    width: 110px; 
    height: 110px;
    top: 35px; 
    right: 8px;
    border-radius: 12px;
    border: 1.5px solid rgba(255, 255, 255, 0.35);
    background: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
  }
  #minimap canvas {
    width: 110px; 
    height: 110px;
  }
}

#msg {
  position:fixed; top:50%; left:50%; transform:translate(-50%,-60%);
  color:#fff; font-size:22px; font-weight:700; text-align:center;
  text-shadow:0 0 12px #000; pointer-events:none; opacity:0;
  transition:opacity 0.5s;
}

#controls-hint {
  position:fixed; bottom:100px; left:50%; transform:translateX(-50%);
  color:rgba(255,255,255,0.55); font-size:12px; text-align:center;
  pointer-events:none;
}

@media (orientation: landscape) and (max-width: 915px) {
  #controls-hint {
    display:none;
  }
}

/* MENU */
#control-menu, #menu {
  position:fixed; inset:0; background:rgba(0,0,0,0.92);
  display:flex; flex-direction:column; align-items:center;
  justify-content:center; z-index:100; gap:14px;
  padding: 20px;
  overflow-y: auto;
}
#control-menu h1, #menu h1 {
  font-size:42px; font-weight:900; letter-spacing:3px;
  background:linear-gradient(135deg,#f1c40f,#e67e22,#c0392b);
  -webkit-background-clip:text; -webkit-text-fill-color:transparent;
  margin-bottom:10px;
}
#control-menu h2, #menu h2 { color:#aaa; font-size:16px; margin-bottom:20px; font-weight:400; }
.faction-btn {
  width:320px; padding:16px 24px; border-radius:12px; border:2px solid;
  cursor:pointer; pointer-events:all; font-size:15px; font-weight:700;
  transition:all 0.2s; text-align:left; background:rgba(0,0,0,0.5);
}
.faction-btn:hover { transform:scale(1.04); }
.faction-btn .btn-title { font-size:18px; margin-bottom:4px; }
.faction-btn .btn-desc { font-size:12px; font-weight:400; opacity:0.8; }
#btn-elf   { border-color:#27ae60; color:#2ecc71; }
#btn-elf:hover   { background:rgba(39,174,96,0.2); }
#btn-guard { border-color:#2980b9; color:#3498db; }
#btn-guard:hover { background:rgba(41,128,185,0.2); }
#btn-evil  { border-color:#8e44ad; color:#9b59b6; }
#btn-evil:hover  { background:rgba(142,68,173,0.2); }

/* Landscape mode: compact menu */
@media (orientation: landscape) and (max-height: 600px) {
  #control-menu, #menu {
    gap: 6px;
    padding: 10px;
    overflow-y: auto;
    justify-content: flex-start;
    padding-top: 15px;
  }
  #control-menu h1, #menu h1 {
    font-size: 22px;
    margin-bottom: 3px;
  }
  #control-menu h2, #menu h2 {
    font-size: 11px;
    margin-bottom: 6px;
  }
  .faction-btn {
    width: min(280px, 90vw);
    padding: 7px 12px;
  }
  .faction-btn .btn-title {
    font-size: 13px;
    margin-bottom: 2px;
  }
  .faction-btn .btn-desc {
    font-size: 9px;
    line-height: 1.3;
  }
}

/* SHOP */
#shop {
  position:fixed; inset:0; background:rgba(0,0,0,0.88);
  display:none; flex-direction:column; align-items:center;
  justify-content:center; z-index:90; gap:10px;
  padding: 20px;
  overflow-y: auto;
}
#shop h2 { color:#f1c40f; font-size:28px; margin-bottom:10px; }
.shop-grid { 
  display:grid; grid-template-columns:repeat(3,1fr); gap:10px; 
  max-width:600px; max-height:70vh; overflow-y:auto; padding:5px;
}
.shop-item {
  background:rgba(255,255,255,0.07); border:1px solid rgba(255,255,255,0.2);
  border-radius:10px; padding:12px; text-align:center; cursor:pointer;
  pointer-events:all; color:#fff; transition:all 0.2s;
}
.shop-item:hover { background:rgba(255,255,255,0.15); border-color:#f1c40f; }
.shop-item .item-name { font-size:13px; font-weight:700; margin-bottom:4px; }
.shop-item .item-price { color:#f1c40f; font-size:12px; }
.shop-item .item-icon { font-size:28px; margin-bottom:6px; }
#shop-close {
  margin-top:16px; padding:10px 32px; background:#c0392b; color:#fff;
  border:none; border-radius:8px; font-size:15px; cursor:pointer;
  pointer-events:all;
}

/* Landscape mode: compact shop with horizontal grid */
@media (orientation: landscape) and (max-height: 600px) {
  #shop {
    padding: 10px 15px;
    gap: 6px;
    justify-content: flex-start;
    padding-top: 15px;
  }
  #shop h2 {
    font-size: 18px;
    margin-bottom: 8px;
  }
  .shop-grid {
    gap: 6px;
    max-width: 95vw;
    max-height: calc(100vh - 100px);
    grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
  }
  .shop-item {
    padding: 6px;
  }
  .shop-item .item-icon {
    font-size: 20px;
    margin-bottom: 3px;
  }
  .shop-item .item-name {
    font-size: 10px;
    margin-bottom: 2px;
    line-height: 1.2;
  }
  .shop-item .item-price {
    font-size: 9px;
  }
  #shop-close {
    margin-top: 8px;
    padding: 6px 20px;
    font-size: 12px;
  }
}

/* INJURY OVERLAY */
#injury-overlay {
  position:fixed; inset:0; pointer-events:none; z-index:50;
}
#eye-overlay {
  position:fixed; right:0; top:0; width:50%; height:100%;
  background:#000; opacity:0; transition:opacity 0.5s; pointer-events:none; z-index:51;
}
#blood-overlay {
  position:fixed; inset:0; border:0px solid transparent;
  box-shadow:inset 0 0 0px rgba(192,57,43,0); pointer-events:none; z-index:52;
  transition:box-shadow 0.3s;
}

/* LOG */
#log {
  position:fixed; right:12px; top:160px; width:250px;
  max-height:120px; overflow:hidden; pointer-events:none;
  z-index:5;
}
.log-entry {
  font-size:12px; color:rgba(255,255,255,0.85);
  text-shadow:1px 1px 3px #000; line-height:1.5;
  animation:fadeLog 6s forwards;
}
@keyframes fadeLog { 0%{opacity:1} 70%{opacity:1} 100%{opacity:0} }

/* Landscape mode: move log to avoid HUD */
@media (orientation: landscape) and (max-width: 915px) {
  #log {
    top: 60px;
    right: 12px;
    max-height: 80px;
    width: 200px;
  }
  .log-entry {
    font-size: 10px;
  }
}

@media (orientation: landscape) and (max-width: 915px) {
  #log {
    top: 60px; /* Below HUD */
    bottom: auto;
    left: 8px;
    right: auto;
    width: 200px;
    max-height: 70px;
    background: rgba(0, 0, 0, 0.5);
    padding: 4px 8px;
    border-radius: 8px;
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
  }
  .log-entry {
    font-size: 8px;
    line-height: 1.2;
  }
}

@media (orientation: portrait) {
  #log {
    /* Keep mobile portrait settings */
  }
}

#caravan-btn {
  position:fixed; bottom:20px; left:50%; transform:translateX(-50%);
  padding:10px 28px; background:rgba(241,196,15,0.85); color:#000;
  border:none; border-radius:8px; font-size:14px; font-weight:700;
  cursor:pointer; pointer-events:all; display:none; z-index:20;
}
#attack-btn {
  position:fixed; bottom:20px; left:50%; transform:translateX(-50%);
  padding:10px 28px; background:rgba(192,57,43,0.85); color:#fff;
  border:none; border-radius:8px; font-size:14px; font-weight:700;
  cursor:pointer; pointer-events:all; display:none; z-index:20;
}

/* MOBILE CONTROLS */
#mobile-controls {
  position:fixed; inset:0; pointer-events:none; z-index:15; display:none;
}

/* Joystick - large and comfortable */
.joystick {
  position: absolute; 
  bottom: 5vh; 
  left: 3vw; 
  width: min(170px, 23vw); 
  height: min(170px, 23vw);
  background: rgba(255, 255, 255, 0.08); 
  border-radius: 50%; 
  border: 3px solid rgba(255, 255, 255, 0.3);
  pointer-events: all;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
}
.joystick-stick {
  position: absolute; 
  top: 50%; 
  left: 50%; 
  width: 40%; 
  height: 40%;
  background: rgba(255, 255, 255, 0.5); 
  border-radius: 50%; 
  border: 3px solid rgba(255, 255, 255, 0.75);
  transform: translate(-50%, -50%); 
  transition: all 0.1s;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

/* Action buttons - varied sizes for hierarchy */
.mobile-btn {
  position: absolute; 
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.12); 
  border: 3px solid rgba(255, 255, 255, 0.35);
  display: flex; 
  align-items: center; 
  justify-content: center;
  color: #fff; 
  pointer-events: all; 
  user-select: none;
  transition: all 0.15s ease; 
  touch-action: none;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  box-shadow: 0 4px 14px rgba(0, 0, 0, 0.2);
}
.mobile-btn:active { 
  background: rgba(255, 255, 255, 0.28); 
  transform: scale(0.90);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
}

/* Portrait mode positions */
#btn-jump { 
  bottom: 18vh; 
  right: 4vw;
  width: min(80px, 13vw);
  height: min(80px, 13vw);
  font-size: min(30px, 5vw);
}
#btn-attack { 
  bottom: 6vh; 
  right: 4vw;
  width: min(95px, 16vw);
  height: min(95px, 16vw);
  background: rgba(231, 76, 60, 0.18);
  border: 3px solid rgba(231, 76, 60, 0.55);
  font-size: min(36px, 6vw);
}
#btn-interact { 
  bottom: 30vh; 
  right: 4vw;
  width: min(75px, 12vw);
  height: min(75px, 12vw);
  font-size: min(24px, 4vw);
  background: rgba(52, 152, 219, 0.18);
  border: 3px solid rgba(52, 152, 219, 0.5);
}
#btn-shop { display: none; }
#btn-menu { 
  top: 8vh; 
  left: 3vw; 
  width: min(55px, 9vw); 
  height: min(55px, 9vw); 
  font-size: min(20px, 3.8vw); 
  background: rgba(192, 57, 43, 0.75);
  border: 2.5px solid rgba(192, 57, 43, 0.95);
}

.mobile-hint {
  position:fixed; bottom:1vh; left:50%; transform:translateX(-50%);
  color:rgba(255,255,255,0.4); font-size:min(10px, 1.8vw); text-align:center; pointer-events:none;
  white-space:nowrap; padding:0 10px;
}

/* Landscape mode - matching screenshot proportions */
@media (orientation: landscape) {
  .joystick { 
    bottom: 8vh; 
    left: 4vw; 
    width: min(150px, 20vh); 
    height: min(150px, 20vh);
  }
  
  /* Attack button - LARGEST by far, rightmost bottom */
  #btn-attack { 
    bottom: 8vh; 
    right: 4vw;
    width: min(120px, 16vh); 
    height: min(120px, 16vh);
    background: rgba(231, 76, 60, 0.22);
    border: 4px solid rgba(231, 76, 60, 0.65);
    font-size: min(48px, 6.5vh);
  }
  
  /* Jump button - MEDIUM, directly left of attack button */
  #btn-jump { 
    bottom: 8vh; 
    right: calc(4vw + min(130px, 17.5vh));
    width: min(85px, 11vh); 
    height: min(85px, 11vh);
    font-size: min(34px, 5vh);
    border: 3px solid rgba(255, 255, 255, 0.4);
  }
  
  /* Interact button - MEDIUM, directly above attack button */
  #btn-interact { 
    bottom: calc(8vh + min(130px, 17.5vh));
    right: 4vw;
    width: min(85px, 11vh); 
    height: min(85px, 11vh);
    background: rgba(52, 152, 219, 0.22);
    border: 3px solid rgba(52, 152, 219, 0.55);
    font-size: min(28px, 4.2vh);
  }
  
  /* Menu button - top left, small */
  #btn-menu { 
    top: 8vh; 
    left: 4vw; 
    width: min(50px, 7vh); 
    height: min(50px, 7vh);
    font-size: min(18px, 3vh);
  }
  
  .mobile-hint { display: none; }
}

</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div id="ui">
  <div id="crosshair"></div>
  <div id="minimap"><canvas id="mm"></canvas></div>
  <div id="log"></div>
  <div id="msg"></div>
  <div id="controls-hint">WASD ‚Äî –¥–≤–∏–∂–µ–Ω–∏–µ | –õ–ö–ú ‚Äî —É–¥–∞—Ä | E ‚Äî –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ | B ‚Äî –º–∞–≥–∞–∑–∏–Ω | F5 ‚Äî —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å | F9 ‚Äî –∑–∞–≥—Ä—É–∑–∏—Ç—å</div>
  <div id="hud">
    <div class="bar-wrap">
      <span class="bar-label">‚ù§ –ó–¥–æ—Ä–æ–≤—å–µ</span>
      <div class="bar" id="hp-bar"><div class="bar-inner" id="hp-fill" style="width:100%"></div></div>
      <span class="bar-label">‚ö° –í—ã–Ω–æ—Å–ª–∏–≤–æ—Å—Ç—å</span>
      <div class="bar" id="sta-bar"><div class="bar-inner" id="sta-fill" style="width:100%"></div></div>
    </div>
    <div id="gold-hud">üí∞ <span id="gold-val">150</span> –º–æ–Ω–µ—Ç</div>
    <button id="shop-btn-hud" onclick="openShop()">üè™ –ú–∞–≥–∞–∑–∏–Ω</button>
  </div>
</div>

<div id="eye-overlay"></div>
<div id="blood-overlay"></div>

<button id="caravan-btn" onclick="robCaravan()">ü™ô –ì—Ä–∞–±–∏—Ç—å –ö–æ—Ä–æ–≤–∞–Ω—å</button>
<button id="attack-btn"  onclick="launchAttack()">‚öî –ê—Ç–∞–∫–æ–≤–∞—Ç—å!</button>

<!-- MOBILE CONTROLS -->
<div id="mobile-controls">
  <div class="joystick" id="joystick">
    <div class="joystick-stick" id="joystick-stick"></div>
  </div>
  <div class="mobile-btn" id="btn-jump">‚¨Ü</div>
  <div class="mobile-btn" id="btn-attack">‚öî</div>
  <div class="mobile-btn" id="btn-interact">ü§ù</div>
  <div class="mobile-btn" id="btn-menu">‚ò∞</div>
  <div class="mobile-hint">–î–∂–æ–π—Å—Ç–∏–∫: –¥–≤–∏–∂–µ–Ω–∏–µ | ‚öî: –∞—Ç–∞–∫–∞ | ‚¨Ü: –ø—Ä—ã–∂–æ–∫ | ü§ù: –¥–µ–π—Å—Ç–≤–∏–µ</div>
</div>

<!-- CONTROL MODE MENU -->
<div id="control-menu">
  <h1>‚öî –¶–ê–†–°–¢–í–û –§–†–ê–ö–¶–ò–ô</h1>
  <h2>–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è</h2>
  <button class="faction-btn" id="btn-desktop" onclick="selectControlMode('desktop')">
    <div class="btn-title">üñ• –ö–æ–º–ø—å—é—Ç–µ—Ä</div>
    <div class="btn-desc">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: WASD + –ú—ã—à—å</div>
  </button>
  <button class="faction-btn" id="btn-mobile" onclick="selectControlMode('mobile')">
    <div class="btn-title">üì± –¢–µ–ª–µ—Ñ–æ–Ω / –ü–ª–∞–Ω—à–µ—Ç</div>
    <div class="btn-desc">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: –°–µ–Ω—Å–æ—Ä–Ω—ã–µ –∫–Ω–æ–ø–∫–∏ –Ω–∞ —ç–∫—Ä–∞–Ω–µ</div>
  </button>
</div>

<!-- FACTION MENU -->
<div id="menu" style="display:none;">
  <h1>‚öî –¶–ê–†–°–¢–í–û –§–†–ê–ö–¶–ò–ô</h1>
  <h2>Realm of Factions ‚Äî –≤—ã–±–µ—Ä–∏—Ç–µ —Å–≤–æ—é —Å—É–¥—å–±—É</h2>
  <button class="faction-btn" id="btn-elf" onclick="startGame('elf')">
    <div class="btn-title">üåø –õ–µ—Å–Ω—ã–µ –≠–ª—å—Ñ—ã</div>
    <div class="btn-desc">–ì—É—Å—Ç–æ–π –ª–µ—Å, –¥–µ—Ä–µ–≤—è–Ω–Ω—ã–µ –¥–æ–º–∏–∫–∏. –ó–∞—â–∏—â–∞–π—Ç–µ—Å—å –æ—Ç —Å–æ–ª–¥–∞—Ç –∏ –∑–ª–æ–¥–µ—è. –ì—Ä–∞–±—å—Ç–µ –∫–æ—Ä–æ–≤–∞–Ω—ã!</div>
  </button>
  <button class="faction-btn" id="btn-guard" onclick="startGame('guard')">
    <div class="btn-title">üõ° –°—Ç—Ä–∞–∂–∞ –î–≤–æ—Ä—Ü–∞</div>
    <div class="btn-desc">–°–ª—É—à–∞–π—Ç–µ—Å—å –∫–æ–º–∞–Ω–¥–∏—Ä–∞. –ó–∞—â–∏—â–∞–π—Ç–µ –¥–≤–æ—Ä–µ—Ü –æ—Ç —à–ø–∏–æ–Ω–æ–≤ –∏ —ç–ª—å—Ñ–∏–π—Å–∫–∏—Ö –ø–∞—Ä—Ç–∏–∑–∞–Ω.</div>
  </button>
  <button class="faction-btn" id="btn-evil" onclick="startGame('evil')">
    <div class="btn-title">üíÄ –¢—ë–º–Ω—ã–π –í–ª–∞–¥—ã–∫–∞</div>
    <div class="btn-desc">–í—ã —Å–∞–º–∏ —Å–µ–±–µ –∫–æ–º–∞–Ω–¥–∏—Ä. –ü–æ—à–ª–∏—Ç–µ –≤–æ–π—Å–∫–∞ –∑–∞—Ö–≤–∞—Ç–∏—Ç—å –¥–≤–æ—Ä–µ—Ü –∏–ª–∏ —É–Ω–∏—á—Ç–æ–∂–∏—Ç—å —ç–ª—å—Ñ–æ–≤!</div>
  </button>
</div>

<!-- SHOP -->
<div id="shop">
  <h2>üè™ –ú–∞–≥–∞–∑–∏–Ω</h2>
  <div class="shop-grid">
    <div class="shop-item" onclick="buyItem('potion',30)">
      <div class="item-icon">üß™</div>
      <div class="item-name">–ó–µ–ª—å–µ –ª–µ—á–µ–Ω–∏—è</div>
      <div class="item-price">30 –º–æ–Ω–µ—Ç</div>
    </div>
    <div class="shop-item" onclick="buyItem('sword',80)">
      <div class="item-icon">‚öî</div>
      <div class="item-name">–ö–æ—Ä–æ—Ç–∫–∏–π –º–µ—á</div>
      <div class="item-price">80 –º–æ–Ω–µ—Ç</div>
    </div>
    <div class="shop-item" onclick="buyItem('bow',60)">
      <div class="item-icon">üèπ</div>
      <div class="item-name">–õ—É–∫</div>
      <div class="item-price">60 –º–æ–Ω–µ—Ç</div>
    </div>
    <div class="shop-item" onclick="buyItem('armor',120)">
      <div class="item-icon">üõ°</div>
      <div class="item-name">–ö–æ–∂–∞–Ω—ã–π –¥–æ—Å–ø–µ—Ö</div>
      <div class="item-price">120 –º–æ–Ω–µ—Ç</div>
    </div>
    <div class="shop-item" onclick="buyItem('prosthetic_arm',200)">
      <div class="item-icon">ü¶æ</div>
      <div class="item-name">–ü—Ä–æ—Ç–µ–∑ —Ä—É–∫–∏</div>
      <div class="item-price">200 –º–æ–Ω–µ—Ç</div>
    </div>
    <div class="shop-item" onclick="buyItem('prosthetic_leg',250)">
      <div class="item-icon">ü¶ø</div>
      <div class="item-name">–ü—Ä–æ—Ç–µ–∑ –Ω–æ–≥–∏</div>
      <div class="item-price">250 –º–æ–Ω–µ—Ç</div>
    </div>
    <div class="shop-item" onclick="buyItem('eye_patch',80)">
      <div class="item-icon">üè¥‚Äç‚ò†Ô∏è</div>
      <div class="item-name">–ì–ª–∞–∑–Ω–æ–π –ø—Ä–æ—Ç–µ–∑</div>
      <div class="item-price">80 –º–æ–Ω–µ—Ç</div>
    </div>
    <div class="shop-item" onclick="buyItem('food',15)">
      <div class="item-icon">üçñ</div>
      <div class="item-name">–ï–¥–∞</div>
      <div class="item-price">15 –º–æ–Ω–µ—Ç</div>
    </div>
    <div class="shop-item" onclick="buyItem('horse',300)">
      <div class="item-icon">üê¥</div>
      <div class="item-name">–õ–æ—à–∞–¥—å</div>
      <div class="item-price">300 –º–æ–Ω–µ—Ç</div>
    </div>
  </div>
  <button id="shop-close" onclick="closeShop()">–ó–∞–∫—Ä—ã—Ç—å</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ============================================================
//  GAME STATE
// ============================================================
const G = {
  faction: null, hp:100, maxHp:100, stamina:100,
  gold:150, weapon:'fists', armor:false,
  injuries:{ leftArm:false, rightArm:false, leftLeg:false, rightLeg:false, leftEye:false },
  prosthetics:{ arm:false, leg:false, eye:false },
  onWheelchair:false, crawling:false,
  inventory:[], kills:0,
  zones:['neutral','palace','elves','evil'],
  currentZone:'elves',
  caravanNear:false, enemyNear:false, saveData:null,
  controlMode: null // 'desktop' or 'mobile'
};

// ============================================================
//  CONTROL MODE SELECTION
// ============================================================
function selectControlMode(mode) {
  console.log('Selected control mode:', mode);
  G.controlMode = mode;
  document.getElementById('control-menu').style.display = 'none';
  document.getElementById('menu').style.display = 'flex';
  
  if(mode === 'mobile') {
    console.log('Setting up mobile mode...');
    document.getElementById('controls-hint').style.display = 'none';
    const mobileControls = document.getElementById('mobile-controls');
    console.log('Mobile controls element:', mobileControls);
    mobileControls.style.display = 'block';
    // Show shop button in mobile mode
    document.getElementById('shop-btn-hud').style.display = 'inline-block';
    // Initialize mobile controls immediately when mode is selected
    setTimeout(() => {
      console.log('Calling initMobileControls...');
      initMobileControls();
    }, 100);
  } else {
    document.getElementById('mobile-controls').style.display = 'none';
    document.getElementById('controls-hint').style.display = 'block';
    // Hide shop button in desktop mode (use B key instead)
    document.getElementById('shop-btn-hud').style.display = 'none';
  }
}

// ============================================================
//  THREE.JS SCENE
// ============================================================
const canvas = document.getElementById('canvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x4a7c59, 0.018);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 400);
camera.position.set(0, 1.7, 0);

// Lights
const sun = new THREE.DirectionalLight(0xffe8b0, 1.2);
sun.position.set(80, 120, 60);
sun.castShadow = true;
sun.shadow.mapSize.set(2048,2048);
sun.shadow.camera.near = 1;
sun.shadow.camera.far = 400;
sun.shadow.camera.left = -120;
sun.shadow.camera.right = 120;
sun.shadow.camera.top = 120;
sun.shadow.camera.bottom = -120;
scene.add(sun);
scene.add(new THREE.AmbientLight(0x334455, 0.7));
const hemi = new THREE.HemisphereLight(0x87ceeb, 0x4a6741, 0.5);
scene.add(hemi);

// ============================================================
//  GROUND
// ============================================================
// ============================================================
//  TREES
// ============================================================
const trees = [];
function makeTree(x, z, dist) {
  const group = new THREE.Group();
  
  // Realistic proportions: average tree height 8-12m, trunk diameter 0.3-0.5m
  const treeHeight = 8 + Math.random() * 4; // 8-12 meters
  const trunkRadius = 0.15 + Math.random() * 0.1; // 0.15-0.25m
  const foliageRadius = 2 + Math.random() * 1; // 2-3m
  
  // Trunk
  const trunkGeo = new THREE.CylinderGeometry(
    trunkRadius * 0.8, 
    trunkRadius, 
    treeHeight * 0.4, 
    8
  );
  const trunkMat = new THREE.MeshLambertMaterial({ color: 0x5c3d1e });
  const trunk = new THREE.Mesh(trunkGeo, trunkMat);
  trunk.position.y = treeHeight * 0.2;
  trunk.castShadow = true;
  group.add(trunk);
  
  // Foliage (3 cone layers for natural look)
  const green = 0x1a5c14 + Math.floor(Math.random() * 0x0a3010);
  const fMat = new THREE.MeshLambertMaterial({ color: green });
  
  for(let i = 0; i < 3; i++) {
    const r = foliageRadius * (1 - i * 0.25);
    const h = treeHeight * 0.3;
    const fGeo = new THREE.ConeGeometry(r, h, 8);
    const f = new THREE.Mesh(fGeo, fMat);
    f.position.y = treeHeight * 0.35 + i * (h * 0.6);
    f.castShadow = true;
    group.add(f);
  }
  
  group.position.set(x, 0, z);
  group.userData = { isTree: true, dist };
  scene.add(group);
  trees.push(group);
  return group;
}

// For very distant trees, use simpler LOD
function makeSimpleTree(x, z) {
  const group = new THREE.Group();
  
  const treeHeight = 8 + Math.random() * 3;
  const trunkRadius = 0.2;
  
  // Simple trunk
  const trunkGeo = new THREE.CylinderGeometry(trunkRadius * 0.8, trunkRadius, treeHeight * 0.4, 6);
  const trunkMat = new THREE.MeshLambertMaterial({ color: 0x5c3d1e });
  const trunk = new THREE.Mesh(trunkGeo, trunkMat);
  trunk.position.y = treeHeight * 0.2;
  group.add(trunk);
  
  // Single foliage cone
  const green = 0x1a5c14 + Math.floor(Math.random() * 0x0a3010);
  const fGeo = new THREE.ConeGeometry(2, treeHeight * 0.6, 6);
  const fMat = new THREE.MeshLambertMaterial({ color: green });
  const foliage = new THREE.Mesh(fGeo, fMat);
  foliage.position.y = treeHeight * 0.5;
  group.add(foliage);
  
  group.position.set(x, 0, z);
  group.userData = { isTree: true, simple: true };
  scene.add(group);
  trees.push(group);
  return group;
}

// ============================================================
//  BUILDINGS
// ============================================================
function makeBox(w,h,d, color, x,y,z, castShadow=true) {
  const g = new THREE.BoxGeometry(w,h,d);
  const m = new THREE.MeshLambertMaterial({ color });
  const mesh = new THREE.Mesh(g, m);
  mesh.position.set(x,y,z);
  if(castShadow) mesh.castShadow = mesh.receiveShadow = true;
  scene.add(mesh);
  return mesh;
}

// ============================================================
//  ENEMIES / NPCs
// ============================================================
const enemies = [];
let enemyMeshGroup;

function makeEnemy(type, x, z) {
  const g = new THREE.Group();
  const colors = { soldier:0x4060a0, elf:0x2e7d32, evil:0x5d2060 };
  const c = colors[type] || 0x808080;
  
  // Realistic human proportions: 1.7-1.8m tall
  const humanHeight = 1.75;
  const headSize = 0.22;
  const bodyHeight = 0.7;
  const bodyWidth = 0.4;
  const bodyDepth = 0.25;
  const armLength = 0.6;
  const armWidth = 0.12;
  const legLength = 0.85;
  const legWidth = 0.15;
  
  // Body
  const body = new THREE.Mesh(
    new THREE.BoxGeometry(bodyWidth, bodyHeight, bodyDepth),
    new THREE.MeshLambertMaterial({ color: c })
  );
  body.position.y = legLength + bodyHeight / 2;
  body.castShadow = true;
  g.add(body);
  
  // Head
  const head = new THREE.Mesh(
    new THREE.BoxGeometry(headSize, headSize, headSize),
    new THREE.MeshLambertMaterial({ color: 0xfad7a0 })
  );
  head.position.y = legLength + bodyHeight + headSize / 2;
  head.castShadow = true;
  g.add(head);
  
  // Left arm
  const armL = new THREE.Mesh(
    new THREE.BoxGeometry(armWidth, armLength, armWidth),
    new THREE.MeshLambertMaterial({ color: c })
  );
  armL.position.set(-(bodyWidth / 2 + armWidth / 2), legLength + bodyHeight - armLength / 2 + 0.1, 0);
  armL.castShadow = true;
  armL.userData.isArm = true;
  g.add(armL);
  
  // Right arm
  const armR = armL.clone();
  armR.position.set(bodyWidth / 2 + armWidth / 2, legLength + bodyHeight - armLength / 2 + 0.1, 0);
  g.add(armR);
  
  // Left leg
  const legL = new THREE.Mesh(
    new THREE.BoxGeometry(legWidth, legLength, legWidth),
    new THREE.MeshLambertMaterial({ color: c })
  );
  legL.position.set(-bodyWidth / 4, legLength / 2, 0);
  legL.castShadow = true;
  g.add(legL);
  
  // Right leg
  const legR = legL.clone();
  legR.position.set(bodyWidth / 4, legLength / 2, 0);
  g.add(legR);
  
  // Weapon (sword)
  const wep = new THREE.Mesh(
    new THREE.BoxGeometry(0.05, 0.8, 0.05),
    new THREE.MeshLambertMaterial({ color: 0x888888 })
  );
  wep.position.set(bodyWidth / 2 + armWidth + 0.1, legLength + bodyHeight - 0.3, 0);
  wep.castShadow = true;
  g.add(wep);

  g.position.set(x, 0, z);
  g.userData = {
    type, hp:50, maxHp:50, alive:true,
    speed: 0.015+Math.random()*0.01,
    dead:false, deathTimer:0,
    hasArm:true, hasLeg:true
  };
  scene.add(g);
  enemies.push(g);
  return g;
}

// ============================================================
//  CARAVAN
// ============================================================
let caravan = null;
function makeCaravan() {
  const g = new THREE.Group();
  // wagon body
  const body = new THREE.Mesh(new THREE.BoxGeometry(4,1.5,2),
    new THREE.MeshLambertMaterial({ color:0x8b6914 }));
  body.position.y = 1.5; g.add(body);
  // wheels
  for(const [wx,wz] of [[-1.5,0.5,1],[1.5,0.5,1],[-1.5,0.5,-1],[1.5,0.5,-1]]) {
    const wg = new THREE.CylinderGeometry(0.5,0.5,0.2,10);
    const wm = new THREE.MeshLambertMaterial({ color:0x4a3010 });
    const wheel = new THREE.Mesh(wg, wm);
    wheel.rotation.z = Math.PI/2;
    wheel.position.set(wx, 0.5, wz); g.add(wheel);
  }
  // canopy
  const can = new THREE.Mesh(new THREE.BoxGeometry(3.5,1,1.8),
    new THREE.MeshLambertMaterial({ color:0xc8a030, transparent:true, opacity:0.85 }));
  can.position.y = 2.8; g.add(can);

  g.position.set(30, 0, 0);
  g.userData = { gold: 80+Math.floor(Math.random()*120), robbed:false };
  scene.add(g);
  caravan = g;
}

// ============================================================
//  PLAYER CONTROLLER
// ============================================================
const keys = {};
const mobileInput = { x:0, z:0, attack:false, jump:false, interact:false };

document.addEventListener('keydown', e => { keys[e.code]=true; handleKey(e.code); });
document.addEventListener('keyup',   e => { keys[e.code]=false; });

// ============================================================
//  MOBILE CONTROLS
// ============================================================
let mobileControlsInitialized = false;

function initMobileControls() {
  if(mobileControlsInitialized) return;
  
  console.log('Initializing mobile controls...');
  
  try {
    const joystick = document.getElementById('joystick');
    const stick = document.getElementById('joystick-stick');
    
    if(!joystick || !stick) {
      console.error('Joystick elements not found!');
      return;
    }
    
    let touching = false;
    
    function handleJoystickMove(clientX, clientY) {
      const rect = joystick.getBoundingClientRect();
      const centerX = rect.width / 2;
      const centerY = rect.height / 2;
      const maxRadius = rect.width * 0.32; // 32% of joystick size
      
      let dx = clientX - rect.left - centerX;
      let dy = clientY - rect.top - centerY;
      
      const dist = Math.sqrt(dx*dx + dy*dy);
      if(dist > maxRadius) {
        dx = dx / dist * maxRadius;
        dy = dy / dist * maxRadius;
      }
      
      stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
      
      // Normalize to -1 to 1
      mobileInput.x = dx / maxRadius;
      mobileInput.z = dy / maxRadius;
    }
    
    function resetJoystick() {
      stick.style.transform = 'translate(-50%, -50%)';
      mobileInput.x = 0;
      mobileInput.z = 0;
    }
    
    // Touch events
    joystick.addEventListener('touchstart', e => {
      e.preventDefault();
      touching = true;
      const touch = e.touches[0];
      handleJoystickMove(touch.clientX, touch.clientY);
    }, { passive: false });
    
    joystick.addEventListener('touchmove', e => {
      e.preventDefault();
      if(!touching) return;
      const touch = e.touches[0];
      handleJoystickMove(touch.clientX, touch.clientY);
    }, { passive: false });
    
    joystick.addEventListener('touchend', e => {
      e.preventDefault();
      touching = false;
      resetJoystick();
    }, { passive: false });
    
    // Mouse events (for testing on desktop)
    joystick.addEventListener('mousedown', e => {
      touching = true;
      handleJoystickMove(e.clientX, e.clientY);
    });
    
    document.addEventListener('mousemove', e => {
      if(!touching) return;
      handleJoystickMove(e.clientX, e.clientY);
    });
    
    document.addEventListener('mouseup', () => {
      if(touching) {
        touching = false;
        resetJoystick();
      }
    });
    
    // Button handlers - with error checking
    const btnJump = document.getElementById('btn-jump');
    const btnAttack = document.getElementById('btn-attack');
    const btnInteract = document.getElementById('btn-interact');
    const btnMenu = document.getElementById('btn-menu');
    
    if(btnJump) {
      btnJump.addEventListener('touchstart', e => {
        e.preventDefault();
        mobileJump();
      }, { passive: false });
      btnJump.addEventListener('click', mobileJump);
    }
    
    if(btnAttack) {
      btnAttack.addEventListener('touchstart', e => {
        e.preventDefault();
        doAttack();
      }, { passive: false });
      btnAttack.addEventListener('click', doAttack);
    }
    
    if(btnInteract) {
      btnInteract.addEventListener('touchstart', e => {
        e.preventDefault();
        interact();
      }, { passive: false });
      btnInteract.addEventListener('click', interact);
    }
    
    if(btnMenu) {
      btnMenu.addEventListener('touchstart', e => {
        e.preventDefault();
        showMobileMenu();
      }, { passive: false });
      btnMenu.addEventListener('click', showMobileMenu);
    }
    
    mobileControlsInitialized = true;
    console.log('Mobile controls initialized successfully');
    
  } catch(error) {
    console.error('Error initializing mobile controls:', error);
  }
}

function mobileJump() {
  if(onGround && jumpCooldown<=0 && !G.injuries.leftLeg && !G.injuries.rightLeg && !G.onWheelchair && !G.crawling) {
    velY = 0.22; onGround = false; jumpCooldown = 20;
    logMsg('ü¶ò –ü—Ä—ã–∂–æ–∫!');
  }
}

function showMobileMenu() {
  document.getElementById('menu').style.display='flex';
}

// ============================================================
//  CAMERA LOOK CONTROLS (Mobile: Touch drag on screen)
// ============================================================
let lastTouchX = 0, lastTouchY = 0;
let isTouching = false;

canvas.addEventListener('touchstart', e => {
  if(G.controlMode !== 'mobile') return;
  const touch = e.touches[0];
  lastTouchX = touch.clientX;
  lastTouchY = touch.clientY;
  isTouching = true;
});

canvas.addEventListener('touchmove', e => {
  if(G.controlMode !== 'mobile' || !isTouching) return;
  e.preventDefault();
  const touch = e.touches[0];
  const dx = touch.clientX - lastTouchX;
  const dy = touch.clientY - lastTouchY;
  
  yaw.y -= dx * 0.004;
  yaw.x -= dy * 0.004;
  yaw.x = Math.max(-Math.PI/2+0.05, Math.min(Math.PI/2-0.05, yaw.x));
  
  lastTouchX = touch.clientX;
  lastTouchY = touch.clientY;
});

canvas.addEventListener('touchend', e => {
  if(G.controlMode !== 'mobile') return;
  isTouching = false;
});

const yaw   = new THREE.Euler(0,0,0,'YXZ');
const pitch = new THREE.Euler(0,0,0,'YXZ');
let isLocked = false;

canvas.addEventListener('click', () => {
  if(G.controlMode === 'desktop') {
    canvas.requestPointerLock();
  }
});
document.addEventListener('pointerlockchange', () => {
  isLocked = document.pointerLockElement === canvas;
});
document.addEventListener('mousemove', e => {
  if(!isLocked || G.controlMode !== 'desktop') return;
  yaw.y -= e.movementX * 0.002;
  yaw.x -= e.movementY * 0.002;
  yaw.x = Math.max(-Math.PI/2+0.05, Math.min(Math.PI/2-0.05, yaw.x));
});
document.addEventListener('mousedown', e => {
  if(e.button===0 && isLocked && G.controlMode === 'desktop') doAttack();
});

let velY = 0, onGround = true, jumpCooldown = 0;
const PLAYER_SPEED_NORMAL = 0.085;
let playerSpeed = PLAYER_SPEED_NORMAL;

function handleKey(code) {
  if(code==='Space' && onGround && jumpCooldown<=0 && !G.injuries.leftLeg && !G.injuries.rightLeg && !G.onWheelchair && !G.crawling) {
    velY = 0.22; onGround = false; jumpCooldown = 20;
    logMsg('ü¶ò –ü—Ä—ã–∂–æ–∫!');
  }
  if(code==='KeyB') openShop();
  if(code==='KeyF' && G.caravanNear && G.faction==='elf') robCaravan();
  if(code==='KeyE') interact();
}

function interact() {
  // near caravan?
  if(G.caravanNear) { if(G.faction==='elf') robCaravan(); }
}

function updateMovement() {
  if(G.faction===null) return;
  let speed = playerSpeed;
  if(G.crawling) speed = 0.022;
  else if(G.onWheelchair) speed = 0.055;
  else if(G.injuries.leftLeg || G.injuries.rightLeg) speed = 0.04;

  const dir = new THREE.Vector3();
  
  // Desktop controls
  if(G.controlMode === 'desktop') {
    if(keys['KeyW']) dir.z -= 1;
    if(keys['KeyS']) dir.z += 1;
    if(keys['KeyA']) dir.x -= 1;
    if(keys['KeyD']) dir.x += 1;
  }
  // Mobile controls
  else if(G.controlMode === 'mobile') {
    dir.x = mobileInput.x;
    dir.z = mobileInput.z;
  }
  
  if(dir.length() > 0) {
    dir.normalize();
    dir.applyEuler(new THREE.Euler(0, yaw.y, 0));
    dir.multiplyScalar(speed);
    camera.position.add(dir);
  }

  // Gravity / jump
  velY -= 0.012;
  camera.position.y += velY;
  if(camera.position.y < 1.7) {
    camera.position.y = 1.7;
    velY = 0; onGround = true;
  }
  if(jumpCooldown>0) jumpCooldown--;

  // Keep in bounds
  camera.position.x = Math.max(-190, Math.min(190, camera.position.x));
  camera.position.z = Math.max(-190, Math.min(190, camera.position.z));

  camera.rotation.copy(yaw);
}

// ============================================================
//  COMBAT
// ============================================================
const attackCooldown = { val:0 };
function doAttack() {
  if(attackCooldown.val > 0) return;
  if(G.injuries.rightArm && !G.prosthetics.arm) {
    logMsg('‚ùå –í–∞—à–∞ –ø—Ä–∞–≤–∞—è —Ä—É–∫–∞ –æ—Ç—Ä—É–±–ª–µ–Ω–∞!'); return;
  }
  attackCooldown.val = 30;
  showMsg('‚öî', 500);

  // raycasting
  const ray = new THREE.Raycaster(camera.position,
    new THREE.Vector3(0,0,-1).applyEuler(camera.rotation), 0.1, 3);

  for(const en of enemies) {
    if(!en.userData.alive) continue;
    const hits = ray.intersectObject(en, true);
    if(hits.length > 0) {
      let dmg = 15 + Math.floor(Math.random()*10);
      if(G.weapon==='sword') dmg += 15;
      en.userData.hp -= dmg;

      // Chance to wound enemy
      const woundRoll = Math.random();
      if(woundRoll < 0.15) {
        severeHitEnemy(en, 'arm');
      } else if(woundRoll < 0.22) {
        severeHitEnemy(en, 'leg');
      }

      if(en.userData.hp <= 0) killEnemy(en);
      else logMsg(`‚öî –í—Ä–∞–≥ –ø–æ–ª—É—á–∏–ª ${dmg} —É—Ä–æ–Ω–∞! (${en.userData.hp}/${en.userData.maxHp})`);
      break;
    }
  }
}

function severeHitEnemy(en, part) {
  if(part==='arm' && en.userData.hasArm) {
    en.userData.hasArm = false;
    en.children.forEach(c => { if(c.userData.isArm) c.visible=false; });
    logMsg('üí• –í—ã –æ—Ç—Ä—É–±–∏–ª–∏ –≤—Ä–∞–≥—É —Ä—É–∫—É!');
  }
  if(part==='leg' && en.userData.hasLeg) {
    en.userData.hasLeg = false;
    en.userData.speed *= 0.4;
    logMsg('üí• –í—ã –æ—Ç—Ä—É–±–∏–ª–∏ –≤—Ä–∞–≥—É –Ω–æ–≥—É! –û–Ω –ø–æ–ª–∑—ë—Ç...');
  }
}

function killEnemy(en) {
  en.userData.alive = false; en.userData.dead = true;
  en.rotation.z = Math.PI/2;
  en.position.y = -0.4;
  G.kills++;
  const loot = 10 + Math.floor(Math.random()*25);
  G.gold += loot;
  updateHUD();
  logMsg(`üíÄ –í—Ä–∞–≥ —É–±–∏—Ç! +${loot} –º–æ–Ω–µ—Ç. –í—Å–µ–≥–æ —É–±–∏–π—Å—Ç–≤: ${G.kills}`);
}

// ============================================================
//  ENEMY AI
// ============================================================
let aiTimer = 0;
function updateEnemies() {
  aiTimer++;
  let nearEnemy = false;
  enemies.forEach(en => {
    if(!en.userData.alive) {
      en.userData.deathTimer++;
      // corpse stays (3D) ‚Äî just lies there
      return;
    }
    const dx = camera.position.x - en.position.x;
    const dz = camera.position.z - en.position.z;
    const dist = Math.sqrt(dx*dx+dz*dz);

    // Move toward player if close
    if(dist < 22) {
      const nx = dx/dist, nz = dz/dist;
      en.position.x += nx * en.userData.speed;
      en.position.z += nz * en.userData.speed;
      en.lookAt(camera.position.x, 0, camera.position.z);

      // Arm animation
      en.children.forEach(c => {
        if(c.userData && c.userData.isArm) {
          c.rotation.x = Math.sin(aiTimer*0.08)*0.5;
        }
      });

      if(dist < 1.8 && aiTimer % 60 === 0) {
        // Attack player
        let dmg = 8 + Math.floor(Math.random()*8);
        const roll = Math.random();
        if(roll < 0.04 && !G.injuries.rightArm) {
          injurePlayer('rightArm');
        } else if(roll < 0.07 && !G.injuries.rightLeg) {
          injurePlayer('rightLeg');
        } else if(roll < 0.085 && !G.injuries.leftEye) {
          injurePlayer('leftEye');
        } else {
          G.hp = Math.max(0, G.hp - dmg);
          logMsg(`ü©∏ –í—Ä–∞–≥ –∞—Ç–∞–∫—É–µ—Ç! -${dmg} HP`);
          flashBlood();
        }
        updateHUD();
        if(G.hp<=0) gameOver();
        nearEnemy = true;
      }
      nearEnemy = true;
    }
    // billboard billboard facing
    if(en.userData.isBillboard) en.lookAt(camera.position);
  });
  G.enemyNear = nearEnemy;
}

// ============================================================
//  INJURY SYSTEM
// ============================================================
function injurePlayer(part) {
  if(G.injuries[part]) return;
  G.injuries[part] = true;
  const msgs = {
    rightArm: 'ü©∏ –í–∞–º –æ—Ç—Ä—É–±–∏–ª–∏ –ø—Ä–∞–≤—É—é —Ä—É–∫—É! –ù–∞–π–¥–∏—Ç–µ –ª–µ–∫–∞—Ä—è –∏–ª–∏ –∫—É–ø–∏—Ç–µ –ø—Ä–æ—Ç–µ–∑, –∏–Ω–∞—á–µ —É–º—Ä—ë—Ç–µ!',
    leftArm:  'ü©∏ –í–∞–º –æ—Ç—Ä—É–±–∏–ª–∏ –ª–µ–≤—É—é —Ä—É–∫—É!',
    rightLeg: 'ü©∏ –í–∞–º –æ—Ç—Ä—É–±–∏–ª–∏ –Ω–æ–≥—É! –í—ã –ø–æ–ª–∑—ë—Ç–µ –∏–ª–∏ –º–æ–∂–µ—Ç–µ –∫—É–ø–∏—Ç—å –ø—Ä–æ—Ç–µ–∑.',
    leftLeg:  'ü©∏ –í–∞–º –ø–æ–≤—Ä–µ–¥–∏–ª–∏ –Ω–æ–≥—É!',
    leftEye:  'ü©∏ –í–∞–º –≤—ã–∫–æ–ª–æ–ª–∏ –≥–ª–∞–∑! –ü–æ–ª–æ–≤–∏–Ω–∞ –æ–±–∑–æ—Ä–∞ –ø–æ—Ç–µ—Ä—è–Ω–∞!'
  };
  logMsg(msgs[part] || 'ü©∏ –í—ã —Ä–∞–Ω–µ–Ω—ã!');

  if(part==='leftEye' && !G.prosthetics.eye) {
    document.getElementById('eye-overlay').style.opacity='1';
  }
  if(part==='rightLeg' || part==='leftLeg') {
    if(!G.prosthetics.leg) {
      // 50% chance wheelchair, 50% crawl
      if(Math.random()<0.5) { G.onWheelchair=true; logMsg('ü¶º –í—ã –ø–µ—Ä–µ–¥–≤–∏–≥–∞–µ—Ç–µ—Å—å –Ω–∞ –∫–æ–ª—è—Å–∫–µ!'); }
      else { G.crawling=true; logMsg('üêõ –í—ã –ø–æ–ª–∑—ë—Ç–µ –ø–æ –∑–µ–º–ª–µ...'); }
    }
  }
  if(part==='rightArm') {
    // bleed out if not healed
    if(!G.prosthetics.arm) startBleed();
  }
  G.hp -= 20;
  updateHUD();
  flashBlood();
  if(G.hp<=0) gameOver();
}

let bleedInterval = null;
function startBleed() {
  if(bleedInterval) return;
  logMsg('ü©∏ –í—ã —Ç–µ—Ä—è–µ—Ç–µ –∫—Ä–æ–≤—å! –í–∞–º –Ω—É–∂–Ω–æ –ª–µ—á–µ–Ω–∏–µ!');
  bleedInterval = setInterval(() => {
    if(G.injuries.rightArm && !G.prosthetics.arm) {
      G.hp -= 3;
      updateHUD();
      flashBlood();
      if(G.hp<=0) { clearInterval(bleedInterval); gameOver(); }
    } else {
      clearInterval(bleedInterval); bleedInterval=null;
    }
  }, 3000);
}

function flashBlood() {
  const el = document.getElementById('blood-overlay');
  el.style.boxShadow='inset 0 0 60px rgba(192,57,43,0.7)';
  setTimeout(()=>el.style.boxShadow='inset 0 0 0px rgba(192,57,43,0)',400);
}

// ============================================================
//  CARAVAN ROBBERY
// ============================================================
function makeCaravanBtn(show) {
  document.getElementById('caravan-btn').style.display = show ? 'block' : 'none';
}
function robCaravan() {
  if(!caravan || caravan.userData.robbed) return;
  caravan.userData.robbed = true;
  const loot = caravan.userData.gold;
  G.gold += loot;
  makeCaravanBtn(false);
  logMsg(`ü™ô –í—ã –æ–≥—Ä–∞–±–∏–ª–∏ –∫–æ—Ä–æ–≤–∞–Ω! +${loot} –º–æ–Ω–µ—Ç!`);
  updateHUD();
  // fade caravan
  caravan.traverse(c=>{ if(c.material) c.material.opacity=0.3; c.material && (c.material.transparent=true); });
}

// ============================================================
//  SHOP
// ============================================================
function openShop() {
  document.exitPointerLock();
  document.getElementById('shop').style.display='flex';
}
function closeShop() {
  document.getElementById('shop').style.display='none';
}
function buyItem(item, price) {
  if(G.gold < price) { logMsg('üí∏ –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–æ–Ω–µ—Ç!'); return; }
  G.gold -= price;
  G.inventory.push(item);
  const msgs = {
    potion: () => {
      const heal = 30 + (G.armor ? 5 : 0);
      G.hp = Math.min(G.maxHp, G.hp + heal);
      logMsg(`üß™ –í—ã –≤—ã–ø–∏–ª–∏ –∑–µ–ª—å–µ! +${heal} HP`);
    },
    sword: () => { G.weapon='sword'; logMsg('‚öî –¢–µ–ø–µ—Ä—å —É –≤–∞—Å –µ—Å—Ç—å –º–µ—á!'); },
    bow:   () => { G.weapon='bow';   logMsg('üèπ –¢–µ–ø–µ—Ä—å —É –≤–∞—Å –µ—Å—Ç—å –ª—É–∫!'); },
    armor: () => { G.armor=true;    logMsg('üõ° –í—ã –Ω–∞–¥–µ–ª–∏ –∫–æ–∂–∞–Ω—ã–π –¥–æ—Å–ø–µ—Ö!'); G.maxHp=120; },
    prosthetic_arm: () => {
      G.prosthetics.arm=true;
      if(bleedInterval){ clearInterval(bleedInterval); bleedInterval=null; }
      G.injuries.rightArm=false;
      logMsg('ü¶æ –ü—Ä–æ—Ç–µ–∑ —Ä—É–∫–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω! –í—ã —Å–Ω–æ–≤–∞ –º–æ–∂–µ—Ç–µ —Å—Ä–∞–∂–∞—Ç—å—Å—è!');
    },
    prosthetic_leg: () => {
      G.prosthetics.leg=true; G.crawling=false; G.onWheelchair=false;
      G.injuries.rightLeg=false; G.injuries.leftLeg=false;
      logMsg('ü¶ø –ü—Ä–æ—Ç–µ–∑ –Ω–æ–≥–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω! –í—ã —Å–Ω–æ–≤–∞ –º–æ–∂–µ—Ç–µ —Ö–æ–¥–∏—Ç—å!');
    },
    eye_patch: () => {
      G.prosthetics.eye=true; G.injuries.leftEye=false;
      document.getElementById('eye-overlay').style.opacity='0';
      logMsg('üëÅ –ì–ª–∞–∑–Ω–æ–π –ø—Ä–æ—Ç–µ–∑ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!');
    },
    food: () => { G.stamina=Math.min(100, G.stamina+40); logMsg('üçñ –í—ã –ø–æ–µ–ª–∏. –í—ã–Ω–æ—Å–ª–∏–≤–æ—Å—Ç—å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞!'); },
    horse: () => { playerSpeed=0.16; logMsg('üê¥ –í—ã –∫—É–ø–∏–ª–∏ –ª–æ—à–∞–¥—å! –°–∫–æ—Ä–æ—Å—Ç—å –ø–µ—Ä–µ–¥–≤–∏–∂–µ–Ω–∏—è —É–¥–≤–æ–µ–Ω–∞!'); }
  };
  if(msgs[item]) msgs[item]();
  updateHUD();
}

// ============================================================
//  FACTION ABILITIES
// ============================================================
function launchAttack() {
  if(G.faction==='evil') {
    logMsg('üíÄ –í—ã –≤–µ–¥—ë—Ç–µ —Å–≤–æ—ë –≤–æ–π—Å–∫–æ –≤ –∞—Ç–∞–∫—É –Ω–∞ –¥–≤–æ—Ä–µ—Ü! –ì–µ–Ω–µ—Ä–∞–ª—å–Ω–æ–µ –Ω–∞—Å—Ç—É–ø–ª–µ–Ω–∏–µ!');
    showMsg('‚öî –ê–¢–ê–ö–ê!', 2000);
    spawnAllies(5);
    document.getElementById('attack-btn').style.display='none';
  }
}

function spawnAllies(count) {
  for(let i=0;i<count;i++) {
    const ally = makeEnemy('evil', camera.position.x+(Math.random()-0.5)*6,
      camera.position.z+(Math.random()-0.5)*6);
    ally.userData.isAlly=true;
    // allies won't attack player
  }
}

// ============================================================
//  MINIMAP
// ============================================================
const mmCanvas = document.getElementById('mm');
const mmCtx = mmCanvas.getContext('2d');
const ZONE_COLORS = {
  neutral:'#c8a050', palace:'#4080c0', elves:'#2d7a2d', evil:'#6030a0'
};

function getMinimapSize() {
  const container = document.getElementById('minimap');
  const rect = container.getBoundingClientRect();
  return { width: rect.width, height: rect.height };
}

function drawMinimap() {
  const size = getMinimapSize();
  // Update canvas size if needed
  if(mmCanvas.width !== size.width || mmCanvas.height !== size.height) {
    mmCanvas.width = size.width;
    mmCanvas.height = size.height;
  }
  
  const w = mmCanvas.width;
  const h = mmCanvas.height;
  const hw = w / 2; // half width
  const hh = h / 2; // half height
  
  mmCtx.fillStyle='#111'; mmCtx.fillRect(0,0,w,h);
  
  // Draw zones with correct mapping:
  // Top-left (0,0 to hw,hh): x<0, z>0 = Neutral
  // Top-right (hw,0 to w,hh): x>0, z>0 = Palace  
  // Bottom-left (0,hh to hw,h): x<0, z<0 = Elves
  // Bottom-right (hw,hh to w,h): x>0, z<0 = Evil
  
  // Since canvas Y goes down but world Z goes up, we need to flip:
  // Top of canvas = positive Z (north)
  // Bottom of canvas = negative Z (south)
  
  mmCtx.fillStyle='#c8a05044'; mmCtx.fillRect(0,0,hw,hh);        // Top-left: Neutral
  mmCtx.fillStyle='#4080c044'; mmCtx.fillRect(hw,0,hw,hh);       // Top-right: Palace
  mmCtx.fillStyle='#2d7a2d44'; mmCtx.fillRect(0,hh,hw,hh);       // Bottom-left: Elves
  mmCtx.fillStyle='#6030a044'; mmCtx.fillRect(hw,hh,hw,hh);      // Bottom-right: Evil
  
  // zone labels
  mmCtx.font=`${Math.floor(w/17)}px sans-serif`; mmCtx.textAlign='center';
  mmCtx.fillStyle='#fff';
  mmCtx.fillText('–ù–µ–π—Ç—Ä.',hw/2,hh*0.15);           // Top-left
  mmCtx.fillText('–î–≤–æ—Ä–µ—Ü',hw+hw/2,hh*0.15);        // Top-right
  mmCtx.fillText('–≠–ª—å—Ñ—ã',hw/2,hh+hh*0.15);         // Bottom-left
  mmCtx.fillText('–ó–ª–æ–¥–µ–π',hw+hw/2,hh+hh*0.15);     // Bottom-right

  // enemies - with Z inverted for canvas
  enemies.forEach(en => {
    if(!en.userData.alive) return;
    const mx = hw + (en.position.x/200)*(w/2);      // X: -200 to 200 -> 0 to w
    const mz = hh - (en.position.z/200)*(h/2);      // Z: inverted! +200 -> top, -200 -> bottom
    mmCtx.fillStyle = en.userData.type==='soldier' ? '#5080ff' :
      en.userData.type==='elf' ? '#40c040' : '#c040c0';
    mmCtx.fillRect(mx-2, mz-2, 4, 4);
  });
  
  // caravan - with Z inverted
  if(caravan && !caravan.userData.robbed) {
    const mx = hw+(caravan.position.x/200)*(w/2);
    const mz = hh-(caravan.position.z/200)*(h/2);   // Z inverted
    mmCtx.fillStyle='#f1c40f';
    mmCtx.fillRect(mx-3,mz-3,6,6);
  }
  
  // player - with Z inverted
  mmCtx.fillStyle='#ff4040';
  mmCtx.beginPath();
  const px = hw+(camera.position.x/200)*(w/2);
  const pz = hh-(camera.position.z/200)*(h/2);      // Z inverted
  mmCtx.arc(px, pz, Math.max(3, w/35),0,Math.PI*2);
  mmCtx.fill();
  
  // direction indicator
  mmCtx.strokeStyle='#ff4040'; mmCtx.lineWidth=1.5;
  mmCtx.beginPath();
  mmCtx.moveTo(px,pz);
  mmCtx.lineTo(px-Math.sin(yaw.y)*10, pz+Math.cos(yaw.y)*10);  // Z inverted
  mmCtx.stroke();
}

// ============================================================
//  ZONE DETECTION
// ============================================================
function updateCurrentZone() {
  const x = camera.position.x;
  const z = camera.position.z;
  
  let newZone;
  if (x < 0 && z >= 0) {
    newZone = 'neutral';
  } else if (x >= 0 && z >= 0) {
    newZone = 'palace';
  } else if (x < 0 && z < 0) {
    newZone = 'elves';
  } else {
    newZone = 'evil';
  }
  
  if (newZone !== G.currentZone) {
    G.currentZone = newZone;
    const zoneNames = {
      neutral: 'üèò –ù–µ–π—Ç—Ä–∞–ª—å–Ω—ã–µ –∑–µ–º–ª–∏',
      palace: 'üõ° –ó–µ–º–ª–∏ –ò–º–ø–µ—Ä–∞—Ç–æ—Ä–∞',
      elves: 'üåø –õ–µ—Å–Ω—ã–µ –∑–µ–º–ª–∏ —ç–ª—å—Ñ–æ–≤',
      evil: 'üíÄ –ó–µ–º–ª–∏ –¢—ë–º–Ω–æ–≥–æ –í–ª–∞–¥—ã–∫–∏'
    };
    logMsg(`–í—ã –≤–æ—à–ª–∏ –≤: ${zoneNames[newZone]}`);
    updateFogForZone(newZone);
  }
}

function updateFogForZone(zone) {
  const fogSettings = {
    neutral: { color: 0x8a7560, density: 0.010 },
    palace: { color: 0xa09070, density: 0.008 },
    elves: { color: 0x4a7c59, density: 0.012 },
    evil: { color: 0x1a0f1f, density: 0.015 }
  };
  
  const settings = fogSettings[zone] || fogSettings.neutral;
  scene.fog.color.setHex(settings.color);
  scene.fog.density = settings.density;
  
  // Smoothly transition background color
  const targetColor = new THREE.Color(settings.color);
  scene.background.lerp(targetColor, 0.05);
}

function checkProximity() {
  if(!caravan || caravan.userData.robbed) { G.caravanNear=false; makeCaravanBtn(false); return; }
  const dx = camera.position.x - caravan.position.x;
  const dz = camera.position.z - caravan.position.z;
  const d  = Math.sqrt(dx*dx+dz*dz);
  if(d<6 && G.faction==='elf') {
    G.caravanNear=true; makeCaravanBtn(true);
  } else {
    G.caravanNear=false; makeCaravanBtn(false);
  }
}

// ============================================================
//  SAVE / LOAD
// ============================================================
function saveGame() {
  const data = {
    faction:G.faction, hp:G.hp, maxHp:G.maxHp, stamina:G.stamina,
    gold:G.gold, weapon:G.weapon, armor:G.armor,
    injuries:{...G.injuries}, prosthetics:{...G.prosthetics},
    crawling:G.crawling, onWheelchair:G.onWheelchair,
    kills:G.kills, inventory:[...G.inventory],
    pos:{ x:camera.position.x, y:camera.position.y, z:camera.position.z },
    yaw:{ x:yaw.x, y:yaw.y }
  };
  localStorage.setItem('realm_save', JSON.stringify(data));
  logMsg('üíæ –ò–≥—Ä–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!');
}
function loadGame() {
  const raw = localStorage.getItem('realm_save');
  if(!raw) { logMsg('‚ùå –ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è!'); return; }
  const d = JSON.parse(raw);
  Object.assign(G, d);
  camera.position.set(d.pos.x, d.pos.y, d.pos.z);
  yaw.x=d.yaw.x; yaw.y=d.yaw.y;
  updateHUD();
  if(G.injuries.leftEye && !G.prosthetics.eye)
    document.getElementById('eye-overlay').style.opacity='1';
  logMsg('üìÇ –ò–≥—Ä–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞!');
}
document.addEventListener('keydown', e => {
  if(e.key==='F5'){ e.preventDefault(); saveGame(); }
  if(e.key==='F9'){ e.preventDefault(); loadGame(); }
});

// ============================================================
//  HUD UPDATE
// ============================================================
function updateHUD() {
  document.getElementById('hp-fill').style.width   = (G.hp/G.maxHp*100)+'%';
  document.getElementById('sta-fill').style.width  = (G.stamina/100*100)+'%';
  document.getElementById('gold-val').textContent   = G.gold;
}

// ============================================================
//  LOG
// ============================================================
const logEl = document.getElementById('log');
function logMsg(text) {
  const div = document.createElement('div');
  div.className='log-entry'; div.textContent=text;
  logEl.prepend(div);
  while(logEl.children.length>6) logEl.removeChild(logEl.lastChild);
}

// ============================================================
//  MESSAGE FLASH
// ============================================================
const msgEl = document.getElementById('msg');
function showMsg(text, dur=1200) {
  msgEl.textContent=text; msgEl.style.opacity='1';
  setTimeout(()=>msgEl.style.opacity='0', dur);
}

// ============================================================
//  GAME OVER
// ============================================================
function gameOver() {
  showMsg('üíÄ –í–´ –ü–û–ì–ò–ë–õ–ò!\n\n–ù–∞–∂–º–∏—Ç–µ F9 –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏', 99999);
  G.faction=null;
  setTimeout(()=>{
    const m=document.getElementById('menu'); m.style.display='flex';
    document.exitPointerLock();
  }, 3000);
}

// ============================================================
//  STAMINA REGEN
// ============================================================
let staminaTimer=0;
function regenStamina() {
  staminaTimer++;
  if(staminaTimer%120===0) {
    G.stamina = Math.min(100, G.stamina+5);
    updateHUD();
  }
}

// ============================================================
//  START GAME
// ============================================================
let sceneBuilt=false;
function startGame(faction) {
  console.log('Starting game with faction:', faction, 'control mode:', G.controlMode);
  G.faction=faction;
  document.getElementById('menu').style.display='none';

  // Clear existing
  while(scene.children.length>0) scene.remove(scene.children[0]);
  enemies.length=0; caravan=null;
  scene.add(sun); scene.add(hemi); scene.add(new THREE.AmbientLight(0x334455,0.7));

  console.log('Building all zones...');
  
  // Set initial camera position based on faction
  const startPositions = {
    elf: [-80, 1.7, -80],    // Bottom-left (elves zone)
    guard: [80, 1.7, 80],     // Top-right (palace zone)
    evil: [80, 1.7, -80]      // Bottom-right (evil zone)
  };
  const pos = startPositions[faction] || [0, 1.7, 0];
  camera.position.set(pos[0], pos[1], pos[2]);
  
  // Build the entire world with all 4 zones
  buildWorldZones();
  
  // Spawn enemies in all zones
  spawnEnemiesInAllZones(faction);
  
  // Add caravan for elves
  if(faction === 'elf') {
    makeCaravan();
    document.getElementById('caravan-btn').style.display='none';
  }
  
  // Show appropriate faction message
  const messages = {
    elf: 'üåø –í—ã –≤ –∑–µ–º–ª—è—Ö –ª–µ—Å–Ω—ã—Ö —ç–ª—å—Ñ–æ–≤! –ò—Å—Å–ª–µ–¥—É–π—Ç–µ –º–∏—Ä –∏ –≥—Ä–∞–±—å—Ç–µ –∫–æ—Ä–æ–≤–∞–Ω—ã!',
    guard: 'üõ° –ó–∞—â–∏—â–∞–π—Ç–µ –ò–º–ø–µ—Ä–∞—Ç–æ—Ä—Å–∫–∏–π –¥–≤–æ—Ä–µ—Ü! –ü–æ–¥—á–∏–Ω—è–π—Ç–µ—Å—å –∫–æ–º–∞–Ω–¥–∏—Ä—É.',
    evil: 'üíÄ –í—ã ‚Äî –¢—ë–º–Ω—ã–π –í–ª–∞–¥—ã–∫–∞! –ö–æ–º–∞–Ω–¥—É–π—Ç–µ –≤–æ–π—Å–∫–∞–º–∏ –∏ –∑–∞—Ö–≤–∞—Ç–∏—Ç–µ –º–∏—Ä!'
  };
  logMsg(messages[faction] || '–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∏–≥—Ä—É!');
  
  if(faction === 'guard') {
    // Spawn commander in palace
    const cmd = makeEnemy('soldier', 85, 85);
    cmd.userData.isCommander=true; cmd.userData.isAlly=true;
    cmd.userData.hp=9999; cmd.userData.speed=0;
  }
  
  if(faction === 'evil') {
    document.getElementById('attack-btn').style.display='block';
  }

  yaw.y=0; yaw.x=0;
  G.hp=100; G.maxHp=100; G.stamina=100; G.gold=150;
  Object.keys(G.injuries).forEach(k=>G.injuries[k]=false);
  Object.keys(G.prosthetics).forEach(k=>G.prosthetics[k]=false);
  G.crawling=false; G.onWheelchair=false;
  document.getElementById('eye-overlay').style.opacity='0';
  updateHUD();
  sceneBuilt=true;
  
  // Show mobile controls if in mobile mode
  if(G.controlMode === 'mobile') {
    console.log('Showing mobile controls in game');
    const mobileControls = document.getElementById('mobile-controls');
    mobileControls.style.display = 'block';
    console.log('Mobile controls display:', mobileControls.style.display);
    // Re-initialize if needed
    if(!mobileControlsInitialized) {
      console.log('Re-initializing mobile controls');
      initMobileControls();
    }
  }
  
  // Request pointer lock for desktop mode
  if(G.controlMode === 'desktop') {
    setTimeout(() => canvas.click(), 100);
  }
  
  console.log('Starting animation loop, scene children count:', scene.children.length);
  // Force initial render
  renderer.render(scene, camera);
}

// ============================================================
//  WORLD ZONES BUILDER
// ============================================================
function buildWorldZones() {
  // The world is divided into 4 quadrants:
  // Top-left: Neutral zone (+-x: -200 to 0, +-z: 0 to 200)
  // Top-right: Palace zone (x: 0 to 200, z: 0 to 200)
  // Bottom-left: Elves zone (x: -200 to 0, z: -200 to 0)
  // Bottom-right: Evil zone (x: 0 to 200, z: -200 to 0)
  
  // Base ground for entire world
  const groundGeo = new THREE.PlaneGeometry(400, 400, 64, 64);
  const verts = groundGeo.attributes.position.array;
  
  // Color ground based on zones
  const colors = new Float32Array(verts.length);
  for(let i = 0; i < verts.length; i += 3) {
    const x = verts[i];
    const z = verts[i + 1];
    
    // Add terrain variation
    verts[i + 2] = (Math.random() - 0.5) * 0.8;
    
    // Determine zone color
    let r, g, b;
    if (x < 0 && z >= 0) {
      // Neutral zone - brownish
      r = 0.54; g = 0.45; b = 0.33;
    } else if (x >= 0 && z >= 0) {
      // Palace zone - sandy
      r = 0.7; g = 0.6; b = 0.45;
    } else if (x < 0 && z < 0) {
      // Elves zone - green
      r = 0.18; g = 0.35; b = 0.11;
    } else {
      // Evil zone - dark purple
      r = 0.24; g = 0.19; b = 0.21;
    }
    
    colors[i] = r;
    colors[i + 1] = g;
    colors[i + 2] = b;
  }
  
  groundGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  groundGeo.computeVertexNormals();
  
  const groundMat = new THREE.MeshLambertMaterial({ vertexColors: true });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);
  
  // Build structures in each zone
  buildElvesZone();      // Bottom-left
  buildPalaceZone();     // Top-right
  buildEvilZone();       // Bottom-right
  buildNeutralZone();    // Top-left
}

function buildElvesZone() {
  scene.fog = new THREE.FogExp2(0x4a7c59, 0.008);
  
  // Dense forest in elves zone (-200 to 0, -200 to 0)
  for(let i = 0; i < 120; i++) {
    let x = -20 - Math.random() * 160;
    let z = -20 - Math.random() * 160;
    let d = Math.sqrt(x*x + z*z);
    if(d > 15) {
      // Use detailed trees for closer range, simple trees for far
      if(d < 120) makeTree(x, z, d);
      else makeSimpleTree(x, z);
    }
  }
  
  // Elf village at center of zone
  const elfVillagePos = [[-95, -95], [-75, -95], [-95, -75], [-75, -75]];
  elfVillagePos.forEach(([x, z]) => {
    // Hut (realistic size: 5m x 5m x 3m tall)
    makeBox(5, 3, 5, 0x7b4f2a, x, 1.5, z);
    // Roof
    const rg = new THREE.ConeGeometry(4, 2.5, 4);
    const rm = new THREE.MeshLambertMaterial({ color: 0x5c3010 });
    const roof = new THREE.Mesh(rg, rm);
    roof.position.set(x, 4, z);
    roof.rotation.y = Math.PI / 4;
    roof.castShadow = true;
    scene.add(roof);
    // Door
    makeBox(0.8, 1.8, 0.1, 0x3d1f00, x, 0.9, z + 2.55);
  });
}

function buildPalaceZone() {
  // Lighter fog for palace
  
  // Sparse trees in palace zone (0 to 200, 0 to 200)
  for(let i = 0; i < 25; i++) {
    let x = 20 + Math.random() * 160;
    let z = 20 + Math.random() * 160;
    let d = Math.sqrt((x-85)*(x-85) + (z-85)*(z-85));
    if(d > 25) {
      if(d < 120) makeTree(x, z, d);
      else makeSimpleTree(x, z);
    }
  }
  
  // Palace at center (around 85, 85) - realistic castle size
  const px = 85, pz = 85;
  // Walls (6m tall)
  makeBox(30, 6, 2, 0xc8b99a, px, 3, pz + 14);
  makeBox(30, 6, 2, 0xc8b99a, px, 3, pz - 14);
  makeBox(2, 6, 30, 0xc8b99a, px + 14, 3, pz);
  makeBox(2, 6, 30, 0xc8b99a, px - 14, 3, pz);
  // Towers (15m tall)
  [[13,13],[13,-13],[-13,13],[-13,-13]].forEach(([ox, oz]) => {
    makeBox(3, 15, 3, 0xb8a888, px + ox, 7.5, pz + oz);
    makeBox(3.8, 1, 3.8, 0xa08060, px + ox, 15.5, pz + oz);
  });
  // Main building (12m tall)
  makeBox(12, 12, 10, 0xd4c4a0, px, 6, pz);
  // Roof
  const rg = new THREE.BoxGeometry(13, 2, 11);
  const rm = new THREE.MeshLambertMaterial({ color: 0x6a5030 });
  const roof = new THREE.Mesh(rg, rm);
  roof.position.set(px, 13, pz);
  scene.add(roof);
}

function buildEvilZone() {
  // Dark fog for evil zone
  
  // Few trees in evil zone (0 to 200, -200 to 0)
  for(let i = 0; i < 15; i++) {
    let x = 20 + Math.random() * 160;
    let z = -20 - Math.random() * 160;
    let d = Math.sqrt(x*x + z*z);
    if(d > 20) {
      if(d < 120) makeTree(x, z, d);
      else makeSimpleTree(x, z);
    }
  }
  
  // Mountains around evil fort (around 85, -85) - realistic mountain size
  const ex = 85, ez = -85;
  for(let i = 0; i < 10; i++) {
    const angle = (i / 10) * Math.PI * 2;
    const r = 28 + Math.random() * 10;
    const h = 15 + Math.random() * 20; // 15-35m tall mountains
    const mg = new THREE.ConeGeometry(8 + Math.random() * 6, h, 6);
    const mm = new THREE.MeshLambertMaterial({ color: 0x3a3040 });
    const mt = new THREE.Mesh(mg, mm);
    mt.position.set(ex + Math.cos(angle) * r, h / 2, ez + Math.sin(angle) * r);
    mt.castShadow = true;
    scene.add(mt);
  }
  
  // Evil fort (smaller, realistic medieval fort)
  makeBox(20, 8, 2, 0x4a3840, ex, 4, ez + 10);
  makeBox(20, 8, 2, 0x4a3840, ex, 4, ez - 10);
  makeBox(2, 8, 22, 0x4a3840, ex + 10, 4, ez);
  makeBox(2, 8, 22, 0x4a3840, ex - 10, 4, ez);
  makeBox(3, 12, 3, 0x3d2f3c, ex + 9, 6, ez - 9);
  makeBox(3, 12, 3, 0x3d2f3c, ex - 9, 6, ez - 9);
  makeBox(10, 6, 8, 0x2d1f2c, ex, 3, ez);
}

function buildNeutralZone() {
  // Medium forest in neutral zone (-200 to 0, 0 to 200)
  for(let i = 0; i < 40; i++) {
    let x = -20 - Math.random() * 160;
    let z = 20 + Math.random() * 160;
    let d = Math.sqrt(x*x + z*z);
    if(d > 15) {
      if(d < 120) makeTree(x, z, d);
      else makeSimpleTree(x, z);
    }
  }
  
  // Small village or trading post (realistic cottage size)
  const houses = [[-100, 100], [-80, 100]];
  houses.forEach(([x, z]) => {
    makeBox(4, 3, 4, 0x8b7355, x, 1.5, z);
    const rg = new THREE.ConeGeometry(3.5, 2, 4);
    const rm = new THREE.MeshLambertMaterial({ color: 0x704020 });
    const roof = new THREE.Mesh(rg, rm);
    roof.position.set(x, 4, z);
    roof.rotation.y = Math.PI / 4;
    roof.castShadow = true;
    scene.add(roof);
  });
}

// ============================================================
//  ENEMY SPAWNING IN ALL ZONES
// ============================================================
function spawnEnemiesInAllZones(playerFaction) {
  // Elves zone: spawn soldiers and evil minions (enemies of elves)
  if(playerFaction !== 'elf') {
    for(let i = 0; i < 4; i++) {
      const x = -30 - Math.random() * 120;
      const z = -30 - Math.random() * 120;
      makeEnemy('elf', x, z);
    }
  } else {
    for(let i = 0; i < 6; i++) {
      const x = -30 - Math.random() * 120;
      const z = -30 - Math.random() * 120;
      const type = Math.random() > 0.5 ? 'soldier' : 'evil';
      makeEnemy(type, x, z);
    }
  }
  
  // Palace zone: spawn guards and maybe elves (if player is evil)
  if(playerFaction !== 'guard') {
    for(let i = 0; i < 5; i++) {
      const x = 50 + Math.random() * 60;
      const z = 50 + Math.random() * 60;
      makeEnemy('soldier', x, z);
    }
  } else {
    for(let i = 0; i < 4; i++) {
      const x = 50 + Math.random() * 60;
      const z = 50 + Math.random() * 60;
      const type = Math.random() > 0.5 ? 'elf' : 'evil';
      makeEnemy(type, x, z);
    }
  }
  
  // Evil zone: spawn evil minions
  if(playerFaction !== 'evil') {
    for(let i = 0; i < 5; i++) {
      const x = 50 + Math.random() * 60;
      const z = -50 - Math.random() * 60;
      makeEnemy('evil', x, z);
    }
  } else {
    for(let i = 0; i < 4; i++) {
      const x = 50 + Math.random() * 60;
      const z = -50 - Math.random() * 60;
      const type = Math.random() > 0.5 ? 'soldier' : 'elf';
      makeEnemy(type, x, z);
    }
  }
  
  // Neutral zone: mixed enemies
  for(let i = 0; i < 3; i++) {
    const x = -50 - Math.random() * 100;
    const z = 50 + Math.random() * 100;
    const types = ['soldier', 'elf', 'evil'];
    const type = types[Math.floor(Math.random() * types.length)];
    makeEnemy(type, x, z);
  }
}

// ============================================================
//  LOD: distant trees as billboard, near trees as 3D
// ============================================================
function updateTreeLOD() {
  // Simple culling - hide very distant trees
  trees.forEach(t => {
    const dx = camera.position.x - t.position.x;
    const dz = camera.position.z - t.position.z;
    const d = Math.sqrt(dx*dx + dz*dz);
    // Show trees within 150 units
    t.visible = d < 150;
  });
}

// ============================================================
//  MAIN LOOP
// ============================================================
let animationId = null;
function animate(ts=0) {
  animationId = requestAnimationFrame(animate);
  
  if(G.faction===null || !sceneBuilt) {
    // Just render the scene even if game hasn't started
    renderer.render(scene, camera);
    return;
  }

  updateMovement();
  updateEnemies();
  updateTreeLOD();
  updateCurrentZone();  // Check which zone player is in
  checkProximity();
  regenStamina();
  drawMinimap();
  if(attackCooldown.val>0) attackCooldown.val--;

  renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Handle orientation change for mobile
window.addEventListener('orientationchange', () => {
  setTimeout(() => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }, 100);
});

// Initial render of menu bg and start animation loop
(function init() {
  scene.background = new THREE.Color(0x0a0a18);
  renderer.render(scene, camera);
  // Start animation loop immediately
  animate();
})();
</script>
</body>
</html>
